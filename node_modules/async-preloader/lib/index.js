import FontFaceObserver from "fontfaceobserver-es";
import { LoaderKey, } from "./types.js";
const isSafari = /^((?!chrome|android).)*safari/i.test(globalThis.navigator?.userAgent) ===
    true;
/**
 * AsyncPreloader: assets preloader using ES2017 async/await and fetch.
 *
 * It exports an instance of itself as default so you can:
 *
 * ```js
 * import Preloader from "async-preloader";
 *
 * await Preloader.loadItems([]);
 * ```
 *
 * to use directly as a singleton or
 *
 * ```js
 * import { AsyncPreloader as Preloader } from "async-preloader";
 *
 * const preloader = new Preloader();
 * await preloader.loadItems([]);
 * ```
 * if you need more than one instance.
 */
class AsyncPreloader {
    constructor() {
        // Properties
        /**
         * Object that contains the loaded items
         */
        this.items = new Map();
        /**
         * Default body method to be called on the Response from fetch if no body option is specified on the LoadItem
         */
        this.defaultBodyMethod = "blob";
        /**
         * Default loader to use if no loader key is specified in the {@link LoadItem} or if the extension doesn't match any of the {@link AsyncPreloader.loaders} extensions
         */
        this.defaultLoader = LoaderKey.Text;
        // API
        /**
         * Load the specified manifest (array of items)
         *
         * @param {(LoadItem[] | string[])} items Items to load
         * @returns {Promise<LoadedValue[]>} Resolve when all items are loaded, reject for any error
         */
        this.loadItems = async (items) => {
            return await Promise.all(items.map(this.loadItem));
        };
        /**
         * Load a single item
         *
         * @param {(LoadItem | string)} item Item to load
         * @returns {Promise<LoadedValue>} Resolve when item is loaded, reject for any error
         */
        this.loadItem = async (item) => {
            if (typeof item === "string")
                item = { src: item };
            const extension = AsyncPreloader.getFileExtension(item.src || "");
            const loaderKey = item.loader || AsyncPreloader.getLoaderKey(extension);
            const loadedItem = await this[`load` + loaderKey](item);
            this.items.set((item.id || item.src), loadedItem);
            return loadedItem;
        };
        // Special loaders
        /**
         * Load a manifest of items
         *
         * @param {string} src Manifest src url
         * @param {string} [key="items"] Manifest key in the JSON object containing the array of LoadItem.
         * @returns {Promise<LoadedValue[]>}
         */
        this.loadManifest = async (src, key = "items") => {
            const loadedManifest = await this.loadJson({
                src,
            });
            const items = AsyncPreloader.getProp(loadedManifest, key);
            return await this.loadItems(items);
        };
        // Text loaders
        /**
         * Load an item and parse the Response as text
         *
         * @param {LoadItem} item Item to load
         * @returns {Promise<string>} Fulfilled value of parsed Response
         */
        this.loadText = async (item) => {
            const response = await AsyncPreloader.fetchItem(item);
            return await response.text();
        };
        /**
         * Load an item and parse the Response as json
         *
         * @param {LoadItem} item Item to load
         * @returns {Promise<JSON>} Fulfilled value of parsed Response
         */
        this.loadJson = async (item) => {
            const response = await AsyncPreloader.fetchItem(item);
            return await response.json();
        };
        /**
         * Load an item and parse the Response as arrayBuffer
         *
         * @param {LoadItem} item Item to load
         * @returns {Promise<ArrayBuffer>} Fulfilled value of parsed Response
         */
        this.loadArrayBuffer = async (item) => {
            const response = await AsyncPreloader.fetchItem(item);
            return await response.arrayBuffer();
        };
        /**
         * Load an item and parse the Response as blob
         *
         * @param {LoadItem} item Item to load
         * @returns {Promise<Blob>} Fulfilled value of parsed Response
         */
        this.loadBlob = async (item) => {
            const response = await AsyncPreloader.fetchItem(item);
            return await response.blob();
        };
        /**
         * Load an item and parse the Response as formData
         *
         * @param {LoadItem} item Item to load
         * @returns {Promise<FormData>} Fulfilled value of parsed Response
         */
        this.loadFormData = async (item) => {
            const response = await AsyncPreloader.fetchItem(item);
            return await response.formData();
        };
        // Custom loaders
        /**
         * Load an item in one of the following cases:
         * - item's "loader" option set as "Image"
         * - item's "src" option extensions matching the loaders Map
         * - direct call of the method
         *
         * @param {LoadItem} item Item to load
         * @returns {Promise<LoadedValue>} Fulfilled value with a decoded HTMLImageElement instance of or a parsed Response according to the "body" option. Defaults to a decoded HTMLImageElement.
         */
        this.loadImage = async (item) => {
            const image = new Image();
            if (item.body) {
                const response = await AsyncPreloader.fetchItem(item);
                const data = await response[item.body]();
                if (item.body !== "blob")
                    return data;
                return await new Promise((resolve, reject) => {
                    image.addEventListener("load", function load() {
                        image.removeEventListener("load", load);
                        resolve(image);
                    });
                    image.addEventListener("error", function error(event) {
                        image.removeEventListener("error", error);
                        reject(event);
                    });
                    image.src = URL.createObjectURL(data);
                });
            }
            image.src = item.src;
            if (!item.noDecode)
                await image.decode();
            return image;
        };
        /**
         * Load an item in one of the following cases:
         * - item's "loader" option set as "Video"
         * - item's "src" option extensions matching the loaders Map
         * - direct call of the method
         *
         * @param {LoadItem} item Item to load
         * @returns {Promise<LoadedValue>} Fulfilled value of parsed Response according to the "body" option. Defaults to an HTMLVideoElement with a blob as srcObject or src.
         */
        this.loadVideo = async (item) => {
            const response = await AsyncPreloader.fetchItem(item);
            const data = await response[item.body || this.defaultBodyMethod]();
            if (item.body)
                return data;
            const video = document.createElement("video");
            return await new Promise((resolve, reject) => {
                video.addEventListener("canplaythrough", function canplaythrough() {
                    video.removeEventListener("canplaythrough", canplaythrough);
                    resolve(video);
                });
                video.addEventListener("error", function error(event) {
                    video.removeEventListener("error", error);
                    reject(event);
                });
                try {
                    if (isSafari)
                        throw "";
                    video.srcObject = data;
                }
                catch (error) {
                    video.src = URL.createObjectURL(data);
                }
                video.load();
            });
        };
        /**
         * Load an item in one of the following cases:
         * - item's "loader" option set as "Audio"
         * - item's "src" option extensions matching the loaders Map
         * - direct call of the method
         *
         * @param {LoadItem} item Item to load
         * @returns {Promise<LoadedValue>} Fulfilled value of parsed Response according to the "body" option. Defaults to an HTMLAudioElement with a blob as srcObject or src.
         */
        this.loadAudio = async (item) => {
            const response = await AsyncPreloader.fetchItem(item);
            const data = await response[item.body || this.defaultBodyMethod]();
            if (item.body)
                return data;
            const audio = document.createElement("audio");
            audio.autoplay = false;
            audio.preload = "auto";
            return await new Promise((resolve, reject) => {
                audio.addEventListener("canplaythrough", function canplaythrough() {
                    audio.removeEventListener("canplaythrough", canplaythrough);
                    resolve(audio);
                });
                audio.addEventListener("error", function error(event) {
                    audio.removeEventListener("error", error);
                    reject(event);
                });
                try {
                    if (isSafari)
                        throw "";
                    audio.srcObject = data;
                }
                catch (error) {
                    audio.src = URL.createObjectURL(data);
                }
                audio.load();
            });
        };
        /**
         * Load an item in one of the following cases:
         * - item's "loader" option set as "Xml"
         * - item's "src" option extensions matching the loaders Map
         * - direct call of the method
         *
         * @param {LoadItem} item Item to load (need a mimeType specified or default to "application/xml")
         * @returns {Promise<LoadedXMLValue>} Result of Response parsed as a document.
         */
        this.loadXml = async (item) => {
            if (!item.mimeType) {
                const extension = AsyncPreloader.getFileExtension(item.src);
                item = {
                    ...item,
                    mimeType: AsyncPreloader.getMimeType(LoaderKey.Xml, extension),
                };
            }
            if (!AsyncPreloader.domParser) {
                throw new Error("DomParser is not supported.");
            }
            const response = await AsyncPreloader.fetchItem(item);
            const data = await response.text();
            return AsyncPreloader.domParser.parseFromString(data, item.mimeType);
        };
        /**
         * Load a font via FontFace or check a font is loaded via FontFaceObserver instance
         *
         * @param {LoadItem} item Item to load (id correspond to the font family name).
         * @returns {Promise<FontFace | string>} Fulfilled value with FontFace instance or initial id if no src provided.
         */
        this.loadFont = async (item) => {
            const fontName = (item.id ||
                AsyncPreloader.getFileName(item.src));
            const options = (item.fontOptions || {});
            if (!item.src) {
                const font = new FontFaceObserver(fontName, options.variant || {});
                await font.load(options.testString, options.timeout);
                return fontName;
            }
            const source = item.body === "arrayBuffer"
                ? await this.loadArrayBuffer({ src: item.src })
                : `url(${item.src})`;
            const font = new FontFace(fontName, source, options.descriptors);
            return await font.load().then((font) => {
                document.fonts.add(font);
                return font;
            });
        };
    }
    // Utils
    /**
     * Fetch wrapper for LoadItem
     *
     * @param {LoadItem} item Item to fetch
     * @returns {Promise<Response>} Fetch response
     */
    static fetchItem(item) {
        return fetch(item.src, item.options || {});
    }
    /**
     * Get an object property by its path in the form 'a[0].b.c' or ['a', '0', 'b', 'c'].
     * Similar to [lodash.get](https://lodash.com/docs/4.17.5#get).
     *
     * @param {any} object Object with nested properties
     * @param {(string | string[])} path Path to the desired property
     * @returns {any} The returned object property
     */
    static getProp(object, path) {
        const p = Array.isArray(path)
            ? path
            : path.split(".").filter((index) => index.length);
        if (!p.length)
            return object;
        return AsyncPreloader.getProp(object[p.shift()], p);
    }
    /**
     * Get file extension
     *
     * @param {string} path
     * @returns {string}
     */
    static getFileExtension(path) {
        return (path?.match(/[^\\/]\.([^.\\/]+)$/) || [null]).pop();
    }
    /**
     * Get file base name
     *
     * @param {string} path
     * @returns {string}
     */
    static getFileBaseName(path) {
        return path.split(/[\\/]/).pop();
    }
    /**
     * Get file name
     *
     * @param {string} path
     * @returns {string}
     */
    static getFileName(path) {
        return (AsyncPreloader.getFileBaseName(path).split(".").slice(0, -1).join(".") ||
            path);
    }
    /**
     * Retrieve loader key from extension (when the loader option isn't specified in the LoadItem)
     *
     * @param {string} extension
     * @returns {LoaderKey}
     */
    static getLoaderKey(extension) {
        const loader = Array.from(AsyncPreloader.loaders).find((loader) => loader[1].extensions.includes(extension));
        return loader ? loader[0] : LoaderKey.Text;
    }
    /**
     * Retrieve mime type from extension
     *
     * @param {LoaderKey} loaderKey
     * @param {string} extension
     * @returns {string}
     */
    static getMimeType(loaderKey, extension) {
        const loader = AsyncPreloader.loaders.get(loaderKey);
        return loader.mimeType[extension] || loader.defaultMimeType;
    }
}
/**
 * Loader types and the extensions they handle
 *
 * Allows the omission of the loader key in a {@link LoadItem.loader} for some generic extensions
 */
AsyncPreloader.loaders = new Map()
    .set(LoaderKey.Text, { extensions: ["txt"] })
    .set(LoaderKey.Json, { extensions: ["json"] })
    .set(LoaderKey.Image, { extensions: ["jpeg", "jpg", "gif", "png", "webp"] })
    .set(LoaderKey.Video, { extensions: ["webm", "ogg", "mp4"] })
    .set(LoaderKey.Audio, { extensions: ["webm", "ogg", "mp3", "wav", "flac"] })
    .set(LoaderKey.Xml, {
    extensions: ["xml", "svg", "html"],
    mimeType: {
        xml: "text/xml",
        svg: "image/svg+xml",
        html: "text/html",
    },
    defaultMimeType: "text/xml",
})
    .set(LoaderKey.Font, {
    extensions: ["woff2", "woff", "ttf", "otf", "eot"],
});
/**
 * DOMParser instance for the XML loader
 */
AsyncPreloader.domParser = typeof DOMParser !== "undefined" && new DOMParser();
export { AsyncPreloader };
const AsyncPreloaderInstance = new AsyncPreloader();
export default AsyncPreloaderInstance;
//# sourceMappingURL=index.js.map