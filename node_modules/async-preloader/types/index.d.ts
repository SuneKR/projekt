import { BodyMethod, LoadItem, LoadedValue, LoadedXMLValue, LoaderKey } from "./types.js";
/**
 * AsyncPreloader: assets preloader using ES2017 async/await and fetch.
 *
 * It exports an instance of itself as default so you can:
 *
 * ```js
 * import Preloader from "async-preloader";
 *
 * await Preloader.loadItems([]);
 * ```
 *
 * to use directly as a singleton or
 *
 * ```js
 * import { AsyncPreloader as Preloader } from "async-preloader";
 *
 * const preloader = new Preloader();
 * await preloader.loadItems([]);
 * ```
 * if you need more than one instance.
 */
declare class AsyncPreloader {
    /**
     * Object that contains the loaded items
     */
    items: Map<string, LoadedValue>;
    /**
     * Default body method to be called on the Response from fetch if no body option is specified on the LoadItem
     */
    defaultBodyMethod: BodyMethod;
    /**
     * Default loader to use if no loader key is specified in the {@link LoadItem} or if the extension doesn't match any of the {@link AsyncPreloader.loaders} extensions
     */
    defaultLoader: LoaderKey;
    /**
     * Loader types and the extensions they handle
     *
     * Allows the omission of the loader key in a {@link LoadItem.loader} for some generic extensions
     */
    private static loaders;
    /**
     * DOMParser instance for the XML loader
     */
    private static domParser;
    /**
     * Load the specified manifest (array of items)
     *
     * @param {(LoadItem[] | string[])} items Items to load
     * @returns {Promise<LoadedValue[]>} Resolve when all items are loaded, reject for any error
     */
    loadItems: (items: LoadItem[] | string[]) => Promise<LoadedValue[]>;
    /**
     * Load a single item
     *
     * @param {(LoadItem | string)} item Item to load
     * @returns {Promise<LoadedValue>} Resolve when item is loaded, reject for any error
     */
    loadItem: (item: LoadItem | string) => Promise<LoadedValue>;
    /**
     * Load a manifest of items
     *
     * @param {string} src Manifest src url
     * @param {string} [key="items"] Manifest key in the JSON object containing the array of LoadItem.
     * @returns {Promise<LoadedValue[]>}
     */
    loadManifest: (src: string, key?: string) => Promise<LoadedValue[]>;
    /**
     * Load an item and parse the Response as text
     *
     * @param {LoadItem} item Item to load
     * @returns {Promise<string>} Fulfilled value of parsed Response
     */
    loadText: (item: LoadItem) => Promise<string>;
    /**
     * Load an item and parse the Response as json
     *
     * @param {LoadItem} item Item to load
     * @returns {Promise<JSON>} Fulfilled value of parsed Response
     */
    loadJson: (item: LoadItem) => Promise<JSON>;
    /**
     * Load an item and parse the Response as arrayBuffer
     *
     * @param {LoadItem} item Item to load
     * @returns {Promise<ArrayBuffer>} Fulfilled value of parsed Response
     */
    loadArrayBuffer: (item: LoadItem) => Promise<ArrayBuffer>;
    /**
     * Load an item and parse the Response as blob
     *
     * @param {LoadItem} item Item to load
     * @returns {Promise<Blob>} Fulfilled value of parsed Response
     */
    loadBlob: (item: LoadItem) => Promise<Blob>;
    /**
     * Load an item and parse the Response as formData
     *
     * @param {LoadItem} item Item to load
     * @returns {Promise<FormData>} Fulfilled value of parsed Response
     */
    loadFormData: (item: LoadItem) => Promise<FormData>;
    /**
     * Load an item in one of the following cases:
     * - item's "loader" option set as "Image"
     * - item's "src" option extensions matching the loaders Map
     * - direct call of the method
     *
     * @param {LoadItem} item Item to load
     * @returns {Promise<LoadedValue>} Fulfilled value with a decoded HTMLImageElement instance of or a parsed Response according to the "body" option. Defaults to a decoded HTMLImageElement.
     */
    loadImage: (item: LoadItem) => Promise<LoadedValue>;
    /**
     * Load an item in one of the following cases:
     * - item's "loader" option set as "Video"
     * - item's "src" option extensions matching the loaders Map
     * - direct call of the method
     *
     * @param {LoadItem} item Item to load
     * @returns {Promise<LoadedValue>} Fulfilled value of parsed Response according to the "body" option. Defaults to an HTMLVideoElement with a blob as srcObject or src.
     */
    loadVideo: (item: LoadItem) => Promise<LoadedValue>;
    /**
     * Load an item in one of the following cases:
     * - item's "loader" option set as "Audio"
     * - item's "src" option extensions matching the loaders Map
     * - direct call of the method
     *
     * @param {LoadItem} item Item to load
     * @returns {Promise<LoadedValue>} Fulfilled value of parsed Response according to the "body" option. Defaults to an HTMLAudioElement with a blob as srcObject or src.
     */
    loadAudio: (item: LoadItem) => Promise<LoadedValue>;
    /**
     * Load an item in one of the following cases:
     * - item's "loader" option set as "Xml"
     * - item's "src" option extensions matching the loaders Map
     * - direct call of the method
     *
     * @param {LoadItem} item Item to load (need a mimeType specified or default to "application/xml")
     * @returns {Promise<LoadedXMLValue>} Result of Response parsed as a document.
     */
    loadXml: (item: LoadItem) => Promise<LoadedXMLValue>;
    /**
     * Load a font via FontFace or check a font is loaded via FontFaceObserver instance
     *
     * @param {LoadItem} item Item to load (id correspond to the font family name).
     * @returns {Promise<FontFace | string>} Fulfilled value with FontFace instance or initial id if no src provided.
     */
    loadFont: (item: LoadItem) => Promise<FontFace | string>;
    /**
     * Fetch wrapper for LoadItem
     *
     * @param {LoadItem} item Item to fetch
     * @returns {Promise<Response>} Fetch response
     */
    private static fetchItem;
    /**
     * Get an object property by its path in the form 'a[0].b.c' or ['a', '0', 'b', 'c'].
     * Similar to [lodash.get](https://lodash.com/docs/4.17.5#get).
     *
     * @param {any} object Object with nested properties
     * @param {(string | string[])} path Path to the desired property
     * @returns {any} The returned object property
     */
    private static getProp;
    /**
     * Get file extension
     *
     * @param {string} path
     * @returns {string}
     */
    private static getFileExtension;
    /**
     * Get file base name
     *
     * @param {string} path
     * @returns {string}
     */
    private static getFileBaseName;
    /**
     * Get file name
     *
     * @param {string} path
     * @returns {string}
     */
    private static getFileName;
    /**
     * Retrieve loader key from extension (when the loader option isn't specified in the LoadItem)
     *
     * @param {string} extension
     * @returns {LoaderKey}
     */
    private static getLoaderKey;
    /**
     * Retrieve mime type from extension
     *
     * @param {LoaderKey} loaderKey
     * @param {string} extension
     * @returns {string}
     */
    private static getMimeType;
}
export { AsyncPreloader };
declare const AsyncPreloaderInstance: AsyncPreloader;
export default AsyncPreloaderInstance;
